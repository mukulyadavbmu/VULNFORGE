/**
 * ExploitVerifier — Verify exploit reproducibility.
 *
 * Runs an exploit multiple times (default 3) and compares response signatures
 * to determine if the finding is stable and reproducible.
 *
 * Security: 20s max runtime per exploit, timeout-safe, no memory leaks.
 * Integration: Feeds into ConfidenceScorerV2 (extension example, no modification).
 */
import { z } from 'zod';
import { logger } from '../../utils/logger';

const log = logger.child({ module: 'ExploitVerifier' });

// ─── Constants ──────────────────────────────────────────────────────────────

const DEFAULT_ATTEMPTS = 3;
const MAX_ATTEMPTS = 10;
const MAX_RUNTIME_MS = 20_000;
const PER_ATTEMPT_TIMEOUT_MS = 5_000;

// ─── Zod Schemas ────────────────────────────────────────────────────────────

const VerifyInputSchema = z.object({
    endpointId: z.string().min(1).max(2048),
    attackType: z.string().min(1).max(128),
    payload: z.string().min(1).max(10_000),
    attempts: z.number().int().min(1).max(MAX_ATTEMPTS).optional(),
}).strict();

// ─── Types ──────────────────────────────────────────────────────────────────

export interface VerifyInput {
    endpointId: string;
    attackType: string;
    payload: string;
    attempts?: number;
}

export interface VerifyResult {
    reproducible: boolean;
    successRate: number;
    stable: boolean;
    confidence: number;
}

export interface ResponseSignature {
    statusCode: number;
    contentLength: number;
    bodyHash: number;
    hasDiffMarker: boolean;
}

export type ExploitExecutor = (
    endpointId: string,
    attackType: string,
    payload: string,
) => Promise<ExploitAttemptResult>;

export interface ExploitAttemptResult {
    success: boolean;
    statusCode: number;
    contentLength: number;
    bodySnippet: string;
    diffMarkers: string[];
    durationMs: number;
}

// ─── Engine ─────────────────────────────────────────────────────────────────

export class ExploitVerifier {
    private executor: ExploitExecutor;

    /**
     * @param executor - Function that executes a single exploit attempt.
     *   Must return ExploitAttemptResult. Injected for testability.
     */
    constructor(executor: ExploitExecutor) {
        this.executor = executor;
    }

    /**
     * Verify exploit reproducibility by running it multiple times.
     *
     * - Compares response signatures across attempts
     * - Checks status code consistency
     * - Checks diff marker consistency
     * - Timeout: 20s total, 5s per attempt
     *
     * @returns VerifyResult with reproducible, successRate, stable, confidence
     */
    async verify(input: VerifyInput): Promise<VerifyResult> {
        const validated = VerifyInputSchema.parse(input);
        const attempts = validated.attempts ?? DEFAULT_ATTEMPTS;
        const startTime = Date.now();

        log.info('Exploit verification started', {
            endpointId: validated.endpointId,
            attackType: validated.attackType,
            attempts,
        });

        const results: ExploitAttemptResult[] = [];
        const signatures: ResponseSignature[] = [];

        for (let i = 0; i < attempts; i++) {
            // Total runtime guard
            const elapsed = Date.now() - startTime;
            if (elapsed >= MAX_RUNTIME_MS) {
                log.warn('Verification aborted — max runtime exceeded', {
                    endpointId: validated.endpointId,
                    attemptIndex: i,
                    elapsedMs: elapsed,
                });
                break;
            }

            try {
                const result = await this.executeWithTimeout(
                    validated.endpointId,
                    validated.attackType,
                    validated.payload,
                    PER_ATTEMPT_TIMEOUT_MS,
                );
                results.push(result);
                signatures.push(this.buildSignature(result));
            } catch (error) {
                log.debug('Attempt failed', {
                    endpointId: validated.endpointId,
                    attemptIndex: i,
                    error: error instanceof Error ? error.message : 'Unknown',
                });
                // Record as failed attempt
                results.push({
                    success: false,
                    statusCode: 0,
                    contentLength: 0,
                    bodySnippet: '',
                    diffMarkers: [],
                    durationMs: PER_ATTEMPT_TIMEOUT_MS,
                });
                signatures.push({
                    statusCode: 0,
                    contentLength: 0,
                    bodyHash: 0,
                    hasDiffMarker: false,
                });
            }
        }

        const totalDuration = Date.now() - startTime;
        const verifyResult = this.analyzeResults(results, signatures);

        log.info('Exploit verification complete', {
            endpointId: validated.endpointId,
            attackType: validated.attackType,
            reproducible: verifyResult.reproducible,
            successRate: verifyResult.successRate,
            stable: verifyResult.stable,
            confidence: verifyResult.confidence,
            attemptCount: results.length,
            durationMs: totalDuration,
        });

        return verifyResult;
    }

    /**
     * Execute a single attempt with timeout protection.
     */
    private async executeWithTimeout(
        endpointId: string,
        attackType: string,
        payload: string,
        timeoutMs: number,
    ): Promise<ExploitAttemptResult> {
        return Promise.race([
            this.executor(endpointId, attackType, payload),
            new Promise<never>((_, reject) =>
                setTimeout(
                    () => reject(new Error(`Attempt timeout (${timeoutMs}ms)`)),
                    timeoutMs,
                ),
            ),
        ]);
    }

    /**
     * Build a lightweight response signature from an attempt result.
     * Uses DJB2 hash on snippet — no large body storage.
     */
    private buildSignature(result: ExploitAttemptResult): ResponseSignature {
        return {
            statusCode: result.statusCode,
            contentLength: result.contentLength,
            bodyHash: this.djb2Hash(result.bodySnippet),
            hasDiffMarker: result.diffMarkers.length > 0,
        };
    }

    /**
     * Analyze all attempt results to determine reproducibility.
     */
    private analyzeResults(
        results: ExploitAttemptResult[],
        signatures: ResponseSignature[],
    ): VerifyResult {
        if (results.length === 0) {
            return { reproducible: false, successRate: 0, stable: false, confidence: 0 };
        }

        // Success rate
        const successCount = results.filter(r => r.success).length;
        const successRate = successCount / results.length;

        // Reproducibility: success on majority of attempts
        const reproducible = successRate >= 0.66;

        // Stability: check if ALL successful attempts have same signature
        const successfulSigs = signatures.filter((_, i) => results[i].success);
        let stable = false;

        if (successfulSigs.length >= 2) {
            const reference = successfulSigs[0];
            stable = successfulSigs.every(sig =>
                sig.statusCode === reference.statusCode &&
                sig.bodyHash === reference.bodyHash &&
                sig.hasDiffMarker === reference.hasDiffMarker,
            );
        } else if (successfulSigs.length === 1) {
            // Single success — stable by default but lower confidence
            stable = true;
        }

        // Content length consistency (allow 10% variance)
        let lengthConsistent = true;
        if (successfulSigs.length >= 2) {
            const lengths = successfulSigs.map(s => s.contentLength);
            const avgLength = lengths.reduce((a, b) => a + b, 0) / lengths.length;
            if (avgLength > 0) {
                lengthConsistent = lengths.every(
                    l => Math.abs(l - avgLength) / avgLength <= 0.1,
                );
            }
        }

        // Confidence calculation
        let confidence = 0;

        // Base from success rate (0-40)
        confidence += successRate * 40;

        // Stability bonus (0-25)
        if (stable) confidence += 25;

        // Length consistency bonus (0-10)
        if (lengthConsistent) confidence += 10;

        // Diff marker consistency bonus (0-15)
        if (successfulSigs.length >= 2) {
            const allHaveDiff = successfulSigs.every(s => s.hasDiffMarker);
            if (allHaveDiff) confidence += 15;
        }

        // Attempt count bonus (more attempts = higher confidence if consistent)
        if (results.length >= 3 && successRate >= 0.66) {
            confidence += 10;
        }

        confidence = Math.min(Math.round(confidence), 100);

        return { reproducible, successRate, stable, confidence };
    }

    /**
     * DJB2 hash — fast deterministic hash, no crypto dependency.
     */
    private djb2Hash(str: string): number {
        const s = str.slice(0, 500); // Cap at 500 chars
        let hash = 5381;
        for (let i = 0; i < s.length; i++) {
            hash = ((hash << 5) + hash + s.charCodeAt(i)) | 0;
        }
        return hash >>> 0;
    }
}

// ─── Integration Example (does NOT modify ConfidenceScorerV2) ───────────────
//
// import { ExploitVerifier, ExploitExecutor } from './ExploitVerifier';
// import { ConfidenceScorerV2 } from '../scoring/ConfidenceScorerV2';
//
// // 1. Create an executor that wraps your existing attack handler:
// const executor: ExploitExecutor = async (endpointId, attackType, payload) => {
//   const response = await yourAttackHandler(endpointId, attackType, payload);
//   return {
//     success: response.statusCode === 200 && response.hasFinding,
//     statusCode: response.statusCode,
//     contentLength: response.body.length,
//     bodySnippet: response.body.slice(0, 500),
//     diffMarkers: response.diffMarkers ?? [],
//     durationMs: response.duration,
//   };
// };
//
// // 2. Verify exploit:
// const verifier = new ExploitVerifier(executor);
// const result = await verifier.verify({
//   endpointId: '/api/users/1',
//   attackType: 'sqli_probe',
//   payload: "' OR 1=1--",
// });
//
// // 3. Feed into ConfidenceScorerV2 (additive):
// const enhanced = ConfidenceScorerV2.calculate(finding, scanId);
// const adjustedConfidence = result.reproducible
//   ? Math.min(enhanced.finalConfidence + result.confidence * 0.2, 100)
//   : enhanced.finalConfidence * 0.7;
